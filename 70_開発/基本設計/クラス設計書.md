# クラス設計書

## 1. クラス設計概要

### 1.1 設計方針

- **階層化アーキテクチャ**: Controller → Service → Repository → Entity
- **責任分離**: 各層の役割を明確に定義
- **依存性注入**: Spring Framework の DI を活用
- **JPA エンティティ**: Supabase PostgreSQL との連携

### 1.2 クラス分類

- **Entity**: データベーステーブルとのマッピング
- **Repository**: データアクセス層
- **Service**: ビジネスロジック層
- **Controller**: Web プレゼンテーション層
- **DTO**: データ転送オブジェクト
- **Config**: 設定クラス

## 2. Entity クラス設計

### 2.1 User エンティティ

```java
package com.ses.sales.support.entity;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "users")
@EntityListeners(AuditingEntityListener.class)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(unique = true, nullable = false)
    private String email;

    @Column(nullable = false)
    private String passwordHash;

    @Column(nullable = false)
    private String name;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserRole role = UserRole.USER;

    @Column(nullable = false)
    private Boolean isActive = true;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private UserProfile userProfile;

    @OneToMany(mappedBy = "createdBy", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<JobRequirement> jobRequirements = new ArrayList<>();

    // Constructors
    public User() {}

    public User(String email, String passwordHash, String name, UserRole role) {
        this.email = email;
        this.passwordHash = passwordHash;
        this.name = name;
        this.role = role;
    }

    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getPasswordHash() { return passwordHash; }
    public void setPasswordHash(String passwordHash) { this.passwordHash = passwordHash; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public UserRole getRole() { return role; }
    public void setRole(UserRole role) { this.role = role; }

    public Boolean getIsActive() { return isActive; }
    public void setIsActive(Boolean isActive) { this.isActive = isActive; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    public UserProfile getUserProfile() { return userProfile; }
    public void setUserProfile(UserProfile userProfile) { this.userProfile = userProfile; }

    public List<JobRequirement> getJobRequirements() { return jobRequirements; }
    public void setJobRequirements(List<JobRequirement> jobRequirements) { this.jobRequirements = jobRequirements; }
}

public enum UserRole {
    ADMIN, MANAGER, USER
}
```

### 2.2 JobRequirement エンティティ

```java
package com.ses.sales.support.entity;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "job_requirements")
@EntityListeners(AuditingEntityListener.class)
public class JobRequirement {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(nullable = false)
    private String projectName;

    private String clientName;

    @Column(columnDefinition = "TEXT")
    private String description;

    @ElementCollection
    @CollectionTable(name = "job_required_skills", joinColumns = @JoinColumn(name = "job_requirement_id"))
    @Column(name = "skill")
    private List<String> requiredSkills = new ArrayList<>();

    @ElementCollection
    @CollectionTable(name = "job_preferred_skills", joinColumns = @JoinColumn(name = "job_requirement_id"))
    @Column(name = "skill")
    private List<String> preferredSkills = new ArrayList<>();

    @Column(nullable = false)
    private Integer experienceYears;

    private String budgetRange;

    private LocalDate startDate;

    private LocalDate endDate;

    private String location;

    @Enumerated(EnumType.STRING)
    private WorkStyle workStyle;

    @Column(columnDefinition = "TEXT")
    private String additionalRequirements;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private JobStatus status = JobStatus.ACTIVE;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by", nullable = false)
    private User createdBy;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @OneToMany(mappedBy = "jobRequirement", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<MatchingResult> matchingResults = new ArrayList<>();

    // Constructors
    public JobRequirement() {}

    public JobRequirement(String projectName, List<String> requiredSkills, Integer experienceYears, User createdBy) {
        this.projectName = projectName;
        this.requiredSkills = requiredSkills;
        this.experienceYears = experienceYears;
        this.createdBy = createdBy;
    }

    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getProjectName() { return projectName; }
    public void setProjectName(String projectName) { this.projectName = projectName; }

    public String getClientName() { return clientName; }
    public void setClientName(String clientName) { this.clientName = clientName; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public List<String> getRequiredSkills() { return requiredSkills; }
    public void setRequiredSkills(List<String> requiredSkills) { this.requiredSkills = requiredSkills; }

    public List<String> getPreferredSkills() { return preferredSkills; }
    public void setPreferredSkills(List<String> preferredSkills) { this.preferredSkills = preferredSkills; }

    public Integer getExperienceYears() { return experienceYears; }
    public void setExperienceYears(Integer experienceYears) { this.experienceYears = experienceYears; }

    public String getBudgetRange() { return budgetRange; }
    public void setBudgetRange(String budgetRange) { this.budgetRange = budgetRange; }

    public LocalDate getStartDate() { return startDate; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }

    public LocalDate getEndDate() { return endDate; }
    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public WorkStyle getWorkStyle() { return workStyle; }
    public void setWorkStyle(WorkStyle workStyle) { this.workStyle = workStyle; }

    public String getAdditionalRequirements() { return additionalRequirements; }
    public void setAdditionalRequirements(String additionalRequirements) { this.additionalRequirements = additionalRequirements; }

    public JobStatus getStatus() { return status; }
    public void setStatus(JobStatus status) { this.status = status; }

    public User getCreatedBy() { return createdBy; }
    public void setCreatedBy(User createdBy) { this.createdBy = createdBy; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    public List<MatchingResult> getMatchingResults() { return matchingResults; }
    public void setMatchingResults(List<MatchingResult> matchingResults) { this.matchingResults = matchingResults; }
}

public enum JobStatus {
    ACTIVE, CLOSED, CANCELLED
}

public enum WorkStyle {
    REMOTE, ONSITE, HYBRID
}
```

### 2.3 Employee エンティティ

```java
package com.ses.sales.support.entity;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "employees")
@EntityListeners(AuditingEntityListener.class)
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;

    @Column(unique = true, nullable = false)
    private String employeeId;

    @Column(nullable = false)
    private String name;

    private String email;

    private String phone;

    private LocalDate birthDate;

    @Enumerated(EnumType.STRING)
    private Gender gender;

    @Column(columnDefinition = "TEXT")
    private String address;

    private String education;

    @Column(columnDefinition = "JSONB")
    private String certification;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Availability availability = Availability.AVAILABLE;

    private Integer hourlyRate;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<EmployeeSkill> skills = new ArrayList<>();

    @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<MatchingResult> matchingResults = new ArrayList<>();

    // Constructors
    public Employee() {}

    public Employee(String employeeId, String name, Availability availability) {
        this.employeeId = employeeId;
        this.name = name;
        this.availability = availability;
    }

    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getEmployeeId() { return employeeId; }
    public void setEmployeeId(String employeeId) { this.employeeId = employeeId; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getPhone() { return phone; }
    public void setPhone(String phone) { this.phone = phone; }

    public LocalDate getBirthDate() { return birthDate; }
    public void setBirthDate(LocalDate birthDate) { this.birthDate = birthDate; }

    public Gender getGender() { return gender; }
    public void setGender(Gender gender) { this.gender = gender; }

    public String getAddress() { return address; }
    public void setAddress(String address) { this.address = address; }

    public String getEducation() { return education; }
    public void setEducation(String education) { this.education = education; }

    public String getCertification() { return certification; }
    public void setCertification(String certification) { this.certification = certification; }

    public Availability getAvailability() { return availability; }
    public void setAvailability(Availability availability) { this.availability = availability; }

    public Integer getHourlyRate() { return hourlyRate; }
    public void setHourlyRate(Integer hourlyRate) { this.hourlyRate = hourlyRate; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }

    public List<EmployeeSkill> getSkills() { return skills; }
    public void setSkills(List<EmployeeSkill> skills) { this.skills = skills; }

    public List<MatchingResult> getMatchingResults() { return matchingResults; }
    public void setMatchingResults(List<MatchingResult> matchingResults) { this.matchingResults = matchingResults; }
}

public enum Availability {
    AVAILABLE, BUSY, UNAVAILABLE
}

public enum Gender {
    MALE, FEMALE, OTHER
}
```

## 3. Repository インターフェース設計

### 3.1 UserRepository

```java
package com.ses.sales.support.repository;

import com.ses.sales.support.entity.User;
import com.ses.sales.support.entity.UserRole;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, String> {

    Optional<User> findByEmail(String email);

    Optional<User> findByEmailAndIsActive(String email, Boolean isActive);

    List<User> findByRole(UserRole role);

    List<User> findByIsActive(Boolean isActive);

    @Query("SELECT u FROM User u WHERE u.role IN :roles AND u.isActive = true")
    List<User> findByRolesAndActive(@Param("roles") List<UserRole> roles);

    @Query("SELECT COUNT(u) FROM User u WHERE u.isActive = true")
    long countActiveUsers();

    boolean existsByEmail(String email);
}
```

### 3.2 JobRequirementRepository

```java
package com.ses.sales.support.repository;

import com.ses.sales.support.entity.JobRequirement;
import com.ses.sales.support.entity.JobStatus;
import com.ses.sales.support.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface JobRequirementRepository extends JpaRepository<JobRequirement, String> {

    Page<JobRequirement> findByStatus(JobStatus status, Pageable pageable);

    Page<JobRequirement> findByCreatedBy(User createdBy, Pageable pageable);

    List<JobRequirement> findByStatusAndCreatedBy(JobStatus status, User createdBy);

    @Query("SELECT jr FROM JobRequirement jr WHERE jr.status = :status ORDER BY jr.createdAt DESC")
    List<JobRequirement> findByStatusOrderByCreatedAtDesc(@Param("status") JobStatus status);

    @Query("SELECT jr FROM JobRequirement jr WHERE jr.projectName LIKE %:keyword% OR jr.clientName LIKE %:keyword%")
    List<JobRequirement> findByKeyword(@Param("keyword") String keyword);

    @Query("SELECT COUNT(jr) FROM JobRequirement jr WHERE jr.status = :status")
    long countByStatus(@Param("status") JobStatus status);

    @Query("SELECT jr FROM JobRequirement jr WHERE jr.createdAt BETWEEN :startDate AND :endDate")
    List<JobRequirement> findByCreatedAtBetween(@Param("startDate") LocalDateTime startDate,
                                               @Param("endDate") LocalDateTime endDate);
}
```

### 3.3 EmployeeRepository

```java
package com.ses.sales.support.repository;

import com.ses.sales.support.entity.Availability;
import com.ses.sales.support.entity.Employee;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, String> {

    Optional<Employee> findByEmployeeId(String employeeId);

    Page<Employee> findByAvailability(Availability availability, Pageable pageable);

    List<Employee> findByAvailability(Availability availability);

    @Query("SELECT e FROM Employee e WHERE e.name LIKE %:keyword% OR e.employeeId LIKE %:keyword%")
    List<Employee> findByKeyword(@Param("keyword") String keyword);

    @Query("SELECT e FROM Employee e JOIN e.skills s WHERE s.technology = :technology")
    List<Employee> findBySkillTechnology(@Param("technology") String technology);

    @Query("SELECT e FROM Employee e JOIN e.skills s WHERE s.technology = :technology AND s.proficiency = :proficiency")
    List<Employee> findBySkillTechnologyAndProficiency(@Param("technology") String technology,
                                                       @Param("proficiency") String proficiency);

    @Query("SELECT COUNT(e) FROM Employee e WHERE e.availability = :availability")
    long countByAvailability(@Param("availability") Availability availability);

    boolean existsByEmployeeId(String employeeId);
}
```

## 4. Service クラス設計

### 4.1 UserService

```java
package com.ses.sales.support.service;

import com.ses.sales.support.entity.User;
import com.ses.sales.support.entity.UserRole;
import com.ses.sales.support.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    public User createUser(String email, String password, String name, UserRole role) {
        if (userRepository.existsByEmail(email)) {
            throw new IllegalArgumentException("Email already exists: " + email);
        }

        User user = new User();
        user.setEmail(email);
        user.setPasswordHash(passwordEncoder.encode(password));
        user.setName(name);
        user.setRole(role);
        user.setIsActive(true);

        return userRepository.save(user);
    }

    public Optional<User> findByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    public Optional<User> findById(String id) {
        return userRepository.findById(id);
    }

    public List<User> findByRole(UserRole role) {
        return userRepository.findByRole(role);
    }

    public List<User> findActiveUsers() {
        return userRepository.findByIsActive(true);
    }

    public User updateUser(String id, String name, UserRole role) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("User not found: " + id));

        user.setName(name);
        user.setRole(role);

        return userRepository.save(user);
    }

    public void deactivateUser(String id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("User not found: " + id));

        user.setIsActive(false);
        userRepository.save(user);
    }

    public long countActiveUsers() {
        return userRepository.countActiveUsers();
    }
}
```

### 4.2 JobRequirementService

```java
package com.ses.sales.support.service;

import com.ses.sales.support.entity.JobRequirement;
import com.ses.sales.support.entity.JobStatus;
import com.ses.sales.support.entity.User;
import com.ses.sales.support.repository.JobRequirementRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class JobRequirementService {

    @Autowired
    private JobRequirementRepository jobRequirementRepository;

    public JobRequirement createJobRequirement(JobRequirement jobRequirement, User createdBy) {
        jobRequirement.setCreatedBy(createdBy);
        jobRequirement.setStatus(JobStatus.ACTIVE);
        return jobRequirementRepository.save(jobRequirement);
    }

    public Optional<JobRequirement> findById(String id) {
        return jobRequirementRepository.findById(id);
    }

    public Page<JobRequirement> findByStatus(JobStatus status, Pageable pageable) {
        return jobRequirementRepository.findByStatus(status, pageable);
    }

    public Page<JobRequirement> findByCreatedBy(User createdBy, Pageable pageable) {
        return jobRequirementRepository.findByCreatedBy(createdBy, pageable);
    }

    public List<JobRequirement> findByStatusOrderByCreatedAtDesc(JobStatus status) {
        return jobRequirementRepository.findByStatusOrderByCreatedAtDesc(status);
    }

    public List<JobRequirement> findByKeyword(String keyword) {
        return jobRequirementRepository.findByKeyword(keyword);
    }

    public JobRequirement updateJobRequirement(String id, JobRequirement updatedJobRequirement) {
        JobRequirement existingJobRequirement = jobRequirementRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Job requirement not found: " + id));

        existingJobRequirement.setProjectName(updatedJobRequirement.getProjectName());
        existingJobRequirement.setClientName(updatedJobRequirement.getClientName());
        existingJobRequirement.setDescription(updatedJobRequirement.getDescription());
        existingJobRequirement.setRequiredSkills(updatedJobRequirement.getRequiredSkills());
        existingJobRequirement.setPreferredSkills(updatedJobRequirement.getPreferredSkills());
        existingJobRequirement.setExperienceYears(updatedJobRequirement.getExperienceYears());
        existingJobRequirement.setBudgetRange(updatedJobRequirement.getBudgetRange());
        existingJobRequirement.setStartDate(updatedJobRequirement.getStartDate());
        existingJobRequirement.setEndDate(updatedJobRequirement.getEndDate());
        existingJobRequirement.setLocation(updatedJobRequirement.getLocation());
        existingJobRequirement.setWorkStyle(updatedJobRequirement.getWorkStyle());
        existingJobRequirement.setAdditionalRequirements(updatedJobRequirement.getAdditionalRequirements());

        return jobRequirementRepository.save(existingJobRequirement);
    }

    public void updateStatus(String id, JobStatus status) {
        JobRequirement jobRequirement = jobRequirementRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Job requirement not found: " + id));

        jobRequirement.setStatus(status);
        jobRequirementRepository.save(jobRequirement);
    }

    public void deleteJobRequirement(String id) {
        jobRequirementRepository.deleteById(id);
    }

    public long countByStatus(JobStatus status) {
        return jobRequirementRepository.countByStatus(status);
    }
}
```

## 5. Controller クラス設計

### 5.1 JobRequirementController

```java
package com.ses.sales.support.controller;

import com.ses.sales.support.entity.JobRequirement;
import com.ses.sales.support.entity.JobStatus;
import com.ses.sales.support.entity.User;
import com.ses.sales.support.service.JobRequirementService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

@Controller
@RequestMapping("/job-requirements")
public class JobRequirementController {

    @Autowired
    private JobRequirementService jobRequirementService;

    @GetMapping
    public String listJobRequirements(
            @RequestParam(required = false) JobStatus status,
            @RequestParam(required = false) String keyword,
            @PageableDefault(size = 20) Pageable pageable,
            Model model,
            Authentication authentication) {

        User currentUser = (User) authentication.getPrincipal();
        Page<JobRequirement> jobRequirements;

        if (status != null) {
            jobRequirements = jobRequirementService.findByStatus(status, pageable);
        } else if (keyword != null && !keyword.isEmpty()) {
            // キーワード検索の場合はページネーションなし
            model.addAttribute("jobRequirements", jobRequirementService.findByKeyword(keyword));
            model.addAttribute("keyword", keyword);
            return "job-requirements/list";
        } else {
            jobRequirements = jobRequirementService.findByCreatedBy(currentUser, pageable);
        }

        model.addAttribute("jobRequirements", jobRequirements);
        model.addAttribute("status", status);
        model.addAttribute("keyword", keyword);

        return "job-requirements/list";
    }

    @GetMapping("/{id}")
    public String viewJobRequirement(@PathVariable String id, Model model) {
        JobRequirement jobRequirement = jobRequirementService.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Job requirement not found: " + id));

        model.addAttribute("jobRequirement", jobRequirement);
        return "job-requirements/view";
    }

    @GetMapping("/new")
    public String newJobRequirementForm(Model model) {
        model.addAttribute("jobRequirement", new JobRequirement());
        return "job-requirements/form";
    }

    @PostMapping
    public String createJobRequirement(
            @ModelAttribute JobRequirement jobRequirement,
            Authentication authentication,
            RedirectAttributes redirectAttributes) {

        User currentUser = (User) authentication.getPrincipal();
        JobRequirement savedJobRequirement = jobRequirementService.createJobRequirement(jobRequirement, currentUser);

        redirectAttributes.addFlashAttribute("successMessage", "人員募集要項を作成しました");
        return "redirect:/job-requirements/" + savedJobRequirement.getId();
    }

    @GetMapping("/{id}/edit")
    public String editJobRequirementForm(@PathVariable String id, Model model) {
        JobRequirement jobRequirement = jobRequirementService.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Job requirement not found: " + id));

        model.addAttribute("jobRequirement", jobRequirement);
        return "job-requirements/form";
    }

    @PostMapping("/{id}")
    public String updateJobRequirement(
            @PathVariable String id,
            @ModelAttribute JobRequirement jobRequirement,
            RedirectAttributes redirectAttributes) {

        jobRequirementService.updateJobRequirement(id, jobRequirement);
        redirectAttributes.addFlashAttribute("successMessage", "人員募集要項を更新しました");
        return "redirect:/job-requirements/" + id;
    }

    @PostMapping("/{id}/status")
    public String updateStatus(
            @PathVariable String id,
            @RequestParam JobStatus status,
            RedirectAttributes redirectAttributes) {

        jobRequirementService.updateStatus(id, status);
        redirectAttributes.addFlashAttribute("successMessage", "ステータスを更新しました");
        return "redirect:/job-requirements/" + id;
    }

    @PostMapping("/{id}/delete")
    public String deleteJobRequirement(
            @PathVariable String id,
            RedirectAttributes redirectAttributes) {

        jobRequirementService.deleteJobRequirement(id);
        redirectAttributes.addFlashAttribute("successMessage", "人員募集要項を削除しました");
        return "redirect:/job-requirements";
    }
}
```

## 6. DTO クラス設計

### 6.1 JobRequirementDto

```java
package com.ses.sales.support.dto;

import com.ses.sales.support.entity.JobStatus;
import com.ses.sales.support.entity.WorkStyle;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.Max;

import java.time.LocalDate;
import java.util.List;

public class JobRequirementDto {

    private String id;

    @NotBlank(message = "プロジェクト名は必須です")
    private String projectName;

    private String clientName;

    private String description;

    @NotNull(message = "必須スキルは必須です")
    private List<String> requiredSkills;

    private List<String> preferredSkills;

    @NotNull(message = "経験年数は必須です")
    @Min(value = 0, message = "経験年数は0年以上である必要があります")
    @Max(value = 50, message = "経験年数は50年以下である必要があります")
    private Integer experienceYears;

    private String budgetRange;

    private LocalDate startDate;

    private LocalDate endDate;

    private String location;

    private WorkStyle workStyle;

    private String additionalRequirements;

    private JobStatus status;

    // Constructors
    public JobRequirementDto() {}

    // Getters and Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }

    public String getProjectName() { return projectName; }
    public void setProjectName(String projectName) { this.projectName = projectName; }

    public String getClientName() { return clientName; }
    public void setClientName(String clientName) { this.clientName = clientName; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public List<String> getRequiredSkills() { return requiredSkills; }
    public void setRequiredSkills(List<String> requiredSkills) { this.requiredSkills = requiredSkills; }

    public List<String> getPreferredSkills() { return preferredSkills; }
    public void setPreferredSkills(List<String> preferredSkills) { this.preferredSkills = preferredSkills; }

    public Integer getExperienceYears() { return experienceYears; }
    public void setExperienceYears(Integer experienceYears) { this.experienceYears = experienceYears; }

    public String getBudgetRange() { return budgetRange; }
    public void setBudgetRange(String budgetRange) { this.budgetRange = budgetRange; }

    public LocalDate getStartDate() { return startDate; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }

    public LocalDate getEndDate() { return endDate; }
    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }

    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }

    public WorkStyle getWorkStyle() { return workStyle; }
    public void setWorkStyle(WorkStyle workStyle) { this.workStyle = workStyle; }

    public String getAdditionalRequirements() { return additionalRequirements; }
    public void setAdditionalRequirements(String additionalRequirements) { this.additionalRequirements = additionalRequirements; }

    public JobStatus getStatus() { return status; }
    public void setStatus(JobStatus status) { this.status = status; }
}
```

## 7. 設計の特徴

### 7.1 エンティティ設計の特徴

- **JPA アノテーション**: テーブルマッピングの自動化
- **監査機能**: @CreatedDate, @LastModifiedDate
- **関連マッピング**: @OneToMany, @ManyToOne
- **列挙型**: @Enumerated による型安全な列挙値

### 7.2 Repository 設計の特徴

- **Spring Data JPA**: 基本的な CRUD 操作の自動実装
- **カスタムクエリ**: @Query による複雑なクエリ
- **ページネーション**: Pageable による効率的なデータ取得
- **型安全**: コンパイル時の型チェック

### 7.3 Service 設計の特徴

- **トランザクション管理**: @Transactional による自動管理
- **ビジネスロジック**: 複雑な処理の集約
- **例外処理**: 適切な例外の投げ方
- **依存性注入**: @Autowired による自動注入

### 7.4 Controller 設計の特徴

- **RESTful**: 適切な HTTP メソッドの使用
- **Thymeleaf 統合**: サーバーサイドレンダリング
- **バリデーション**: @Valid による入力値検証
- **セキュリティ**: Authentication による認証情報取得
