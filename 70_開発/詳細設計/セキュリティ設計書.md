# セキュリティ設計書

## 1. セキュリティ概要

### 1.1 セキュリティ方針

- **多層防御**: 複数のセキュリティ層による防御
- **最小権限の原則**: 必要最小限の権限のみ付与
- **ゼロトラスト**: 全ての通信を検証
- **継続的監視**: リアルタイムでの脅威検知

### 1.2 セキュリティ要件

- **認証**: 強固なユーザー認証
- **認可**: 細かい権限制御
- **データ保護**: 機密データの暗号化
- **通信保護**: HTTPS 通信の強制
- **監査**: 全操作のログ記録

## 2. 認証・認可設計

### 2.1 認証方式

#### 2.1.1 Supabase Auth + Spring Security 統合方式

**⚠️ 重要: Supabase Auth と Spring Security の統合について**

現在の設計では、Supabase Auth（フロントエンド認証）と Spring Security（バックエンド認証）を統合する必要があります。以下の方式を採用します：

**方式: Supabase JWT を Spring Security で検証**

```java
// Spring Boot側でのSupabase JWT検証設定
@Configuration
@EnableWebSecurity
public class SupabaseSecurityConfig {

    @Value("${supabase.jwt.secret}")
    private String supabaseJwtSecret;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/login", "/register", "/css/**", "/js/**", "/images/**").permitAll()
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/v1/manager/**").hasAnyRole("ADMIN", "MANAGER")
                .anyRequest().authenticated()
            )
            .addFilterBefore(supabaseJwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public SupabaseJwtAuthenticationFilter supabaseJwtAuthenticationFilter() {
        return new SupabaseJwtAuthenticationFilter(supabaseJwtSecret);
    }
}
```

```java
// Supabase JWT検証フィルター
@Component
public class SupabaseJwtAuthenticationFilter extends OncePerRequestFilter {

    private final String jwtSecret;

    public SupabaseJwtAuthenticationFilter(String jwtSecret) {
        this.jwtSecret = jwtSecret;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {

        String token = extractTokenFromRequest(request);

        if (token != null && validateSupabaseToken(token)) {
            String userId = getUserIdFromToken(token);
            String role = getRoleFromToken(token);

            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(userId, null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + role)));
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    private boolean validateSupabaseToken(String token) {
        try {
            Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token);
            return true;
        } catch (JwtException e) {
            return false;
        }
    }

    private String getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(jwtSecret)
            .parseClaimsJws(token)
            .getBody();
        return claims.getSubject();
    }

    private String getRoleFromToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(jwtSecret)
            .parseClaimsJws(token)
            .getBody();
        return claims.get("role", String.class);
    }
}
```

#### 2.1.2 Supabase Auth 設定（フロントエンド側）

```javascript
// Supabase Auth設定（フロントエンド）
const authConfig = {
  providers: ["email"],
  passwordMinLength: 8,
  passwordRequireUppercase: true,
  passwordRequireLowercase: true,
  passwordRequireNumbers: true,
  passwordRequireSpecialChars: true,
  sessionTimeout: 24 * 60 * 60, // 24時間
  refreshTokenRotation: true,
  multiFactorAuth: false, // 将来実装予定
};
```

### 2.2 JWT Token 設計

#### 2.2.1 Supabase JWT Payload 構造

```javascript
// Supabase JWT Payload構造
const jwtPayload = {
  sub: "user-uuid", // ユーザーID
  email: "user@example.com", // メールアドレス
  role: "user", // ロール
  iat: 1640995200, // 発行時刻
  exp: 1641081600, // 有効期限
  iss: "supabase", // 発行者
  aud: "authenticated", // 対象者
  app_metadata: {
    provider: "email",
    providers: ["email"],
  },
  user_metadata: {
    name: "ユーザー名",
  },
};
```

#### 2.2.2 Spring Boot 側での JWT 検証実装

```java
// JWT検証ユーティリティ
@Component
public class SupabaseJwtUtil {

    @Value("${supabase.jwt.secret}")
    private String jwtSecret;

    @Value("${supabase.jwt.issuer}")
    private String jwtIssuer;

    public boolean validateToken(String token) {
        try {
            Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .requireIssuer(jwtIssuer)
                .requireAudience("authenticated")
                .parseClaimsJws(token)
                .getBody();

            // 有効期限チェック
            Date expiration = claims.getExpiration();
            if (expiration.before(new Date())) {
                return false;
            }

            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    public String getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(jwtSecret)
            .parseClaimsJws(token)
            .getBody();
        return claims.getSubject();
    }

    public String getRoleFromToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(jwtSecret)
            .parseClaimsJws(token)
            .getBody();
        return claims.get("role", String.class);
    }
}
```

### 2.3 ロールベースアクセス制御 (RBAC)

```sql
-- ロール定義
CREATE TYPE user_role AS ENUM ('admin', 'manager', 'user');

-- 権限マトリクス
-- admin: 全権限
-- manager: 人員管理、要項管理、マッチング実行
-- user: 要項閲覧、マッチング結果閲覧
```

### 2.4 Row Level Security (RLS) ポリシー

```sql
-- ユーザーテーブルのRLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (auth.uid() = id);

-- 人員募集要項のRLS
ALTER TABLE job_requirements ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view all job requirements" ON job_requirements
    FOR SELECT USING (true);

CREATE POLICY "Users can create job requirements" ON job_requirements
    FOR INSERT WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can update their own job requirements" ON job_requirements
    FOR UPDATE USING (auth.uid() = created_by);

CREATE POLICY "Managers can update all job requirements" ON job_requirements
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM users
            WHERE users.id = auth.uid()
            AND users.role IN ('admin', 'manager')
        )
    );

-- SES人員のRLS
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view all employees" ON employees
    FOR SELECT USING (true);

CREATE POLICY "Managers can manage employees" ON employees
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM users
            WHERE users.id = auth.uid()
            AND users.role IN ('admin', 'manager')
        )
    );

-- マッチング結果のRLS
ALTER TABLE matching_results ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view all matching results" ON matching_results
    FOR SELECT USING (true);

CREATE POLICY "Users can create matching results" ON matching_results
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM job_requirements
            WHERE job_requirements.id = matching_results.job_requirement_id
            AND job_requirements.created_by = auth.uid()
        )
    );
```

## 3. データ保護

### 3.1 暗号化

```javascript
// データベース暗号化
const encryptionConfig = {
  // Supabase自動暗号化
  databaseEncryption: "AES-256",

  // アプリケーションレベル暗号化
  sensitiveFields: ["phone", "address", "hourly_rate"],

  // 暗号化キー管理
  keyRotation: "quarterly",
  keyStorage: "Supabase Vault",
};

// 機密データの暗号化関数
function encryptSensitiveData(data, field) {
  if (encryptionConfig.sensitiveFields.includes(field)) {
    return encrypt(data, getEncryptionKey());
  }
  return data;
}

function decryptSensitiveData(encryptedData, field) {
  if (encryptionConfig.sensitiveFields.includes(field)) {
    return decrypt(encryptedData, getEncryptionKey());
  }
  return encryptedData;
}
```

### 3.2 データマスキング

```javascript
// 個人情報のマスキング
function maskPersonalData(data, userRole) {
  const maskedData = { ...data };

  // 一般ユーザーは一部情報をマスク
  if (userRole === "user") {
    if (maskedData.phone) {
      maskedData.phone = maskedData.phone.replace(
        /(\d{3})\d{4}(\d{4})/,
        "$1****$2"
      );
    }
    if (maskedData.email) {
      const [local, domain] = maskedData.email.split("@");
      maskedData.email = `${local.substring(0, 2)}***@${domain}`;
    }
  }

  return maskedData;
}
```

### 3.3 データバックアップ

```sql
-- 自動バックアップ設定
CREATE OR REPLACE FUNCTION backup_sensitive_data()
RETURNS void AS $$
BEGIN
  -- 日次バックアップ
  INSERT INTO backup_logs (table_name, backup_date, record_count)
  SELECT 'employees', NOW(), COUNT(*) FROM employees;

  INSERT INTO backup_logs (table_name, backup_date, record_count)
  SELECT 'job_requirements', NOW(), COUNT(*) FROM job_requirements;

  -- 暗号化されたバックアップファイルの作成
  PERFORM pg_dump(
    'employees, job_requirements',
    'backup_' || to_char(NOW(), 'YYYYMMDD') || '.sql'
  );
END;
$$ LANGUAGE plpgsql;

-- 日次バックアップのスケジュール
SELECT cron.schedule('daily-backup', '0 2 * * *', 'SELECT backup_sensitive_data();');
```

## 4. 通信セキュリティ

### 4.1 HTTPS 強制

```javascript
// フロントエンド設定
const securityConfig = {
  forceHttps: true,
  hsts: {
    maxAge: 31536000, // 1年
    includeSubDomains: true,
    preload: true,
  },
  csp: {
    "default-src": ["'self'"],
    "script-src": ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
    "style-src": ["'self'", "'unsafe-inline'"],
    "img-src": ["'self'", "data:", "https:"],
    "connect-src": ["'self'", "https://*.supabase.co"],
  },
};

// CSPヘッダーの設定
app.use((req, res, next) => {
  res.setHeader("Content-Security-Policy", buildCSPHeader(securityConfig.csp));
  res.setHeader(
    "Strict-Transport-Security",
    `max-age=${securityConfig.hsts.maxAge}; includeSubDomains; preload`
  );
  next();
});
```

### 4.2 API セキュリティ

```javascript
// API レート制限
const rateLimitConfig = {
  windowMs: 15 * 60 * 1000, // 15分
  max: 100, // リクエスト数制限
  message: "Too many requests from this IP",
  standardHeaders: true,
  legacyHeaders: false,
};

// CORS設定
const corsConfig = {
  origin: process.env.ALLOWED_ORIGINS?.split(",") || ["http://localhost:3000"],
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH"],
  allowedHeaders: ["Content-Type", "Authorization", "apikey"],
};

// API キー検証
function validateApiKey(req, res, next) {
  const apiKey = req.headers["apikey"];
  const validApiKey = process.env.SUPABASE_ANON_KEY;

  if (apiKey !== validApiKey) {
    return res.status(401).json({ error: "Invalid API key" });
  }

  next();
}
```

## 5. 入力値検証・サニタイゼーション

### 5.1 入力値検証

```javascript
// バリデーションスキーマ
const validationSchemas = {
  user: {
    email: {
      required: true,
      type: "email",
      maxLength: 255,
      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    },
    password: {
      required: true,
      minLength: 8,
      maxLength: 128,
      pattern:
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
    },
    name: {
      required: true,
      type: "string",
      minLength: 1,
      maxLength: 100,
      pattern: /^[a-zA-Z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\s]+$/,
    },
  },

  jobRequirement: {
    projectName: {
      required: true,
      type: "string",
      minLength: 1,
      maxLength: 200,
    },
    requiredSkills: {
      required: true,
      type: "array",
      minItems: 1,
      maxItems: 20,
      items: {
        type: "string",
        maxLength: 100,
      },
    },
    experienceYears: {
      required: true,
      type: "number",
      minimum: 0,
      maximum: 50,
    },
  },
};

// バリデーション関数
function validateInput(data, schema) {
  const errors = [];

  for (const [field, rules] of Object.entries(schema)) {
    const value = data[field];

    // 必須チェック
    if (
      rules.required &&
      (value === undefined || value === null || value === "")
    ) {
      errors.push(`${field} is required`);
      continue;
    }

    // 型チェック
    if (rules.type && typeof value !== rules.type) {
      errors.push(`${field} must be ${rules.type}`);
    }

    // 長さチェック
    if (rules.minLength && value.length < rules.minLength) {
      errors.push(`${field} must be at least ${rules.minLength} characters`);
    }

    if (rules.maxLength && value.length > rules.maxLength) {
      errors.push(`${field} must be at most ${rules.maxLength} characters`);
    }

    // パターンチェック
    if (rules.pattern && !rules.pattern.test(value)) {
      errors.push(`${field} format is invalid`);
    }
  }

  return errors;
}
```

### 5.2 SQL インジェクション対策

```javascript
// パラメータ化クエリの使用
function getUserById(userId) {
  // ❌ 危険なクエリ
  // const query = `SELECT * FROM users WHERE id = '${userId}'`;

  // ✅ 安全なクエリ
  const query = "SELECT * FROM users WHERE id = $1";
  return supabase.rpc("get_user_by_id", { user_id: userId });
}

// 動的クエリのサニタイゼーション
function sanitizeQuery(query) {
  // 危険な文字の除去
  return query.replace(/['";\\]/g, "");
}

// ORM使用時の注意点
function createJobRequirement(data) {
  // Supabaseクライアントは自動的にパラメータ化クエリを使用
  return supabase.from("job_requirements").insert({
    project_name: data.projectName,
    required_skills: data.requiredSkills,
    experience_years: data.experienceYears,
  });
}
```

### 5.3 XSS 対策

```javascript
// HTMLエスケープ
function escapeHtml(text) {
  const map = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#039;",
  };

  return text.replace(/[&<>"']/g, (m) => map[m]);
}

// ReactでのXSS対策
function SafeText({ text }) {
  // dangerouslySetInnerHTMLは使用しない
  return <span>{text}</span>;
}

// URLサニタイゼーション
function sanitizeUrl(url) {
  try {
    const parsedUrl = new URL(url);
    const allowedProtocols = ["http:", "https:"];

    if (!allowedProtocols.includes(parsedUrl.protocol)) {
      throw new Error("Invalid protocol");
    }

    return parsedUrl.toString();
  } catch (error) {
    return null;
  }
}
```

## 6. セッション管理

### 6.1 セッション設定

```javascript
// セッション設定
const sessionConfig = {
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === "production",
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000, // 24時間
    sameSite: "strict",
  },
  store: new RedisStore({
    host: process.env.REDIS_HOST,
    port: process.env.REDIS_PORT,
    password: process.env.REDIS_PASSWORD,
  }),
};
```

### 6.2 セッション検証

```javascript
// セッション検証ミドルウェア
function validateSession(req, res, next) {
  if (!req.session.userId) {
    return res.status(401).json({ error: "Session expired" });
  }

  // セッションの有効性チェック
  const sessionAge = Date.now() - req.session.createdAt;
  if (sessionAge > sessionConfig.cookie.maxAge) {
    req.session.destroy();
    return res.status(401).json({ error: "Session expired" });
  }

  next();
}

// セッション無効化
function invalidateSession(req, res) {
  req.session.destroy((err) => {
    if (err) {
      console.error("Session destruction error:", err);
    }
    res.clearCookie("sessionId");
    res.json({ message: "Logged out successfully" });
  });
}
```

## 7. ログ・監査

### 7.1 セキュリティログ

```javascript
// セキュリティイベントログ
const securityEvents = {
  LOGIN_SUCCESS: "login_success",
  LOGIN_FAILURE: "login_failure",
  PASSWORD_CHANGE: "password_change",
  PERMISSION_DENIED: "permission_denied",
  DATA_ACCESS: "data_access",
  DATA_MODIFICATION: "data_modification",
  SUSPICIOUS_ACTIVITY: "suspicious_activity",
};

function logSecurityEvent(event, userId, details = {}) {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event: event,
    userId: userId,
    ipAddress: details.ipAddress,
    userAgent: details.userAgent,
    details: details,
    severity: getEventSeverity(event),
  };

  // ログの保存
  supabase.from("security_logs").insert(logEntry);

  // 高重要度イベントの即座通知
  if (logEntry.severity === "high") {
    notifySecurityTeam(logEntry);
  }
}

function getEventSeverity(event) {
  const severityMap = {
    [securityEvents.LOGIN_SUCCESS]: "low",
    [securityEvents.LOGIN_FAILURE]: "medium",
    [securityEvents.PASSWORD_CHANGE]: "medium",
    [securityEvents.PERMISSION_DENIED]: "medium",
    [securityEvents.DATA_ACCESS]: "low",
    [securityEvents.DATA_MODIFICATION]: "medium",
    [securityEvents.SUSPICIOUS_ACTIVITY]: "high",
  };

  return severityMap[event] || "low";
}
```

### 7.2 監査ログ

```sql
-- 監査ログテーブル
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name VARCHAR(100) NOT NULL,
    operation VARCHAR(20) NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'
    record_id UUID NOT NULL,
    old_values JSONB,
    new_values JSONB,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 監査トリガー関数
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit_logs (table_name, operation, record_id, new_values, user_id)
        VALUES (TG_TABLE_NAME, 'INSERT', NEW.id, to_jsonb(NEW), auth.uid());
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_logs (table_name, operation, record_id, old_values, new_values, user_id)
        VALUES (TG_TABLE_NAME, 'UPDATE', NEW.id, to_jsonb(OLD), to_jsonb(NEW), auth.uid());
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_logs (table_name, operation, record_id, old_values, user_id)
        VALUES (TG_TABLE_NAME, 'DELETE', OLD.id, to_jsonb(OLD), auth.uid());
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 監査トリガーの作成
CREATE TRIGGER audit_trigger_job_requirements
    AFTER INSERT OR UPDATE OR DELETE ON job_requirements
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_trigger_employees
    AFTER INSERT OR UPDATE OR DELETE ON employees
    FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
```

## 8. 脅威検知・対応

### 8.1 異常検知

```javascript
// 異常なアクセスパターンの検知
function detectAnomalousActivity(userId, activity) {
  const anomalies = [];

  // 短時間での大量アクセス
  if (activity.requestCount > 100 && activity.timeWindow < 300000) {
    // 5分で100回以上
    anomalies.push("HIGH_FREQUENCY_ACCESS");
  }

  // 異常な時間帯のアクセス
  const hour = new Date().getHours();
  if (hour < 6 || hour > 22) {
    anomalies.push("UNUSUAL_TIME_ACCESS");
  }

  // 地理的に異常なアクセス
  if (activity.location !== userProfile.lastKnownLocation) {
    anomalies.push("UNUSUAL_LOCATION_ACCESS");
  }

  // 異常なデバイス
  if (activity.userAgent !== userProfile.lastKnownUserAgent) {
    anomalies.push("UNUSUAL_DEVICE_ACCESS");
  }

  return anomalies;
}

// 脅威対応
function handleSecurityThreat(threat, userId) {
  switch (threat.severity) {
    case "high":
      // アカウント一時停止
      suspendUserAccount(userId);
      // セキュリティチームに通知
      notifySecurityTeam(threat);
      break;

    case "medium":
      // 追加認証要求
      requireAdditionalAuth(userId);
      // ログ記録
      logSecurityEvent("THREAT_DETECTED", userId, threat);
      break;

    case "low":
      // ログ記録のみ
      logSecurityEvent("SUSPICIOUS_ACTIVITY", userId, threat);
      break;
  }
}
```

### 8.2 インシデント対応

```javascript
// インシデント対応フロー
const incidentResponse = {
  // 1. 検知
  detect: (event) => {
    if (isSecurityIncident(event)) {
      createIncident(event);
    }
  },

  // 2. 分析
  analyze: (incident) => {
    const impact = assessImpact(incident);
    const severity = determineSeverity(incident, impact);
    return { impact, severity };
  },

  // 3. 対応
  respond: (incident, analysis) => {
    const responsePlan = getResponsePlan(analysis.severity);
    executeResponsePlan(responsePlan, incident);
  },

  // 4. 復旧
  recover: (incident) => {
    restoreAffectedSystems(incident);
    verifySystemIntegrity();
  },

  // 5. 学習
  learn: (incident) => {
    updateSecurityPolicies(incident);
    improveDetectionRules(incident);
  },
};
```

## 9. セキュリティテスト

### 9.1 脆弱性テスト

```javascript
// セキュリティテストスイート
describe("Security Tests", () => {
  test("SQL Injection Prevention", async () => {
    const maliciousInput = "'; DROP TABLE users; --";
    const response = await request(app)
      .get(`/api/users?search=${maliciousInput}`)
      .expect(400);

    expect(response.body.error).toContain("Invalid input");
  });

  test("XSS Prevention", async () => {
    const maliciousScript = '<script>alert("XSS")</script>';
    const response = await request(app)
      .post("/api/job-requirements")
      .send({ projectName: maliciousScript })
      .expect(400);

    expect(response.body.error).toContain("Invalid input");
  });

  test("Authentication Required", async () => {
    const response = await request(app).get("/api/employees").expect(401);

    expect(response.body.error).toContain("Authentication required");
  });

  test("Authorization Check", async () => {
    const userToken = await getAuthToken("user");
    const response = await request(app)
      .delete("/api/employees/123")
      .set("Authorization", `Bearer ${userToken}`)
      .expect(403);

    expect(response.body.error).toContain("Insufficient permissions");
  });
});
```

### 9.2 ペネトレーションテスト

```bash
# OWASP ZAP による自動スキャン
zap-baseline.py -t https://your-app.com -r zap-report.html

# Nmap によるポートスキャン
nmap -sS -O -A your-server.com

# SSL/TLS 設定チェック
testssl.sh https://your-app.com
```

## 10. コンプライアンス

### 10.1 個人情報保護

```javascript
// GDPR対応
const gdprCompliance = {
  // データ処理の法的根拠
  legalBasis: "legitimate_interest",

  // データ保持期間
  retentionPeriod: 365, // 日

  // データ主体の権利
  dataSubjectRights: {
    access: true, // アクセス権
    rectification: true, // 訂正権
    erasure: true, // 削除権
    portability: true, // データポータビリティ
    objection: true, // 異議申し立て権
  },

  // データ保護影響評価
  dpia: {
    required: true,
    lastAssessment: "2024-01-01",
    nextAssessment: "2025-01-01",
  },
};

// データ削除要求の処理
async function handleDataErasureRequest(userId) {
  // 1. データの特定
  const userData = await identifyUserData(userId);

  // 2. 削除の実行
  await deleteUserData(userData);

  // 3. 削除の確認
  await verifyDataDeletion(userId);

  // 4. 削除完了の通知
  await notifyDataErasureCompletion(userId);
}
```

### 10.2 セキュリティ監査

```javascript
// セキュリティ監査チェックリスト
const securityAuditChecklist = {
  authentication: {
    strongPasswords: true,
    multiFactorAuth: false, // 将来実装
    sessionManagement: true,
    passwordPolicy: true,
  },

  authorization: {
    rbac: true,
    rls: true,
    principleOfLeastPrivilege: true,
    regularAccessReview: true,
  },

  dataProtection: {
    encryptionAtRest: true,
    encryptionInTransit: true,
    dataMasking: true,
    backupEncryption: true,
  },

  monitoring: {
    securityLogging: true,
    auditTrail: true,
    anomalyDetection: true,
    incidentResponse: true,
  },

  infrastructure: {
    httpsEnforcement: true,
    securityHeaders: true,
    vulnerabilityScanning: true,
    penetrationTesting: true,
  },
};
```
